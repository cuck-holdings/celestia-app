// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: celestia/lst/v1/tx.proto

package types

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket defines a message to create a new basket
type MsgCreateBasket struct {
	// creator is the address creating the basket
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// validators is the list of validator addresses and their weights
	Validators []ValidatorWeight `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators"`
	// metadata contains optional descriptive information
	Metadata *BasketMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgCreateBasket) Reset()         { *m = MsgCreateBasket{} }
func (m *MsgCreateBasket) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasket) ProtoMessage()    {}
func (*MsgCreateBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{0}
}
func (m *MsgCreateBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasket.Merge(m, src)
}
func (m *MsgCreateBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasket proto.InternalMessageInfo

func (m *MsgCreateBasket) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateBasket) GetValidators() []ValidatorWeight {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *MsgCreateBasket) GetMetadata() *BasketMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// MsgCreateBasketResponse is the response for MsgCreateBasket
type MsgCreateBasketResponse struct {
	// basket_id is the ID of the newly created basket
	BasketId string `protobuf:"bytes,1,opt,name=basket_id,json=basketId,proto3" json:"basket_id,omitempty"`
	// denom is the denomination of the basket token
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgCreateBasketResponse) Reset()         { *m = MsgCreateBasketResponse{} }
func (m *MsgCreateBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBasketResponse) ProtoMessage()    {}
func (*MsgCreateBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{1}
}
func (m *MsgCreateBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBasketResponse.Merge(m, src)
}
func (m *MsgCreateBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBasketResponse proto.InternalMessageInfo

func (m *MsgCreateBasketResponse) GetBasketId() string {
	if m != nil {
		return m.BasketId
	}
	return ""
}

func (m *MsgCreateBasketResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

// MsgMintBasketToken defines a message to mint basket tokens
type MsgMintBasketToken struct {
	// minter is the address minting the basket tokens
	Minter string `protobuf:"bytes,1,opt,name=minter,proto3" json:"minter,omitempty"`
	// basket_id is the ID of the basket to mint tokens for
	BasketId string `protobuf:"bytes,2,opt,name=basket_id,json=basketId,proto3" json:"basket_id,omitempty"`
	// amount is the amount of TIA to stake
	Amount types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgMintBasketToken) Reset()         { *m = MsgMintBasketToken{} }
func (m *MsgMintBasketToken) String() string { return proto.CompactTextString(m) }
func (*MsgMintBasketToken) ProtoMessage()    {}
func (*MsgMintBasketToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{2}
}
func (m *MsgMintBasketToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBasketToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBasketToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBasketToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBasketToken.Merge(m, src)
}
func (m *MsgMintBasketToken) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBasketToken) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBasketToken.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBasketToken proto.InternalMessageInfo

func (m *MsgMintBasketToken) GetMinter() string {
	if m != nil {
		return m.Minter
	}
	return ""
}

func (m *MsgMintBasketToken) GetBasketId() string {
	if m != nil {
		return m.BasketId
	}
	return ""
}

func (m *MsgMintBasketToken) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgMintBasketTokenResponse is the response for MsgMintBasketToken
type MsgMintBasketTokenResponse struct {
	// shares_minted is the amount of basket tokens minted
	SharesMinted cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=shares_minted,json=sharesMinted,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"shares_minted"`
}

func (m *MsgMintBasketTokenResponse) Reset()         { *m = MsgMintBasketTokenResponse{} }
func (m *MsgMintBasketTokenResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintBasketTokenResponse) ProtoMessage()    {}
func (*MsgMintBasketTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{3}
}
func (m *MsgMintBasketTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintBasketTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintBasketTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintBasketTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintBasketTokenResponse.Merge(m, src)
}
func (m *MsgMintBasketTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintBasketTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintBasketTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintBasketTokenResponse proto.InternalMessageInfo

// MsgRedeemBasketToken defines a message to redeem basket tokens
type MsgRedeemBasketToken struct {
	// redeemer is the address redeeming the basket tokens
	Redeemer string `protobuf:"bytes,1,opt,name=redeemer,proto3" json:"redeemer,omitempty"`
	// basket_id is the ID of the basket to redeem tokens from
	BasketId string `protobuf:"bytes,2,opt,name=basket_id,json=basketId,proto3" json:"basket_id,omitempty"`
	// amount is the amount of basket tokens to redeem
	Amount types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgRedeemBasketToken) Reset()         { *m = MsgRedeemBasketToken{} }
func (m *MsgRedeemBasketToken) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemBasketToken) ProtoMessage()    {}
func (*MsgRedeemBasketToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{4}
}
func (m *MsgRedeemBasketToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemBasketToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemBasketToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemBasketToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemBasketToken.Merge(m, src)
}
func (m *MsgRedeemBasketToken) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemBasketToken) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemBasketToken.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemBasketToken proto.InternalMessageInfo

func (m *MsgRedeemBasketToken) GetRedeemer() string {
	if m != nil {
		return m.Redeemer
	}
	return ""
}

func (m *MsgRedeemBasketToken) GetBasketId() string {
	if m != nil {
		return m.BasketId
	}
	return ""
}

func (m *MsgRedeemBasketToken) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgRedeemBasketTokenResponse is the response for MsgRedeemBasketToken
type MsgRedeemBasketTokenResponse struct {
	// pending_redemption_id is the ID of the pending redemption
	PendingRedemptionId uint64 `protobuf:"varint,1,opt,name=pending_redemption_id,json=pendingRedemptionId,proto3" json:"pending_redemption_id,omitempty"`
	// completion_time is when the redemption will complete
	CompletionTime string `protobuf:"bytes,2,opt,name=completion_time,json=completionTime,proto3" json:"completion_time,omitempty"`
}

func (m *MsgRedeemBasketTokenResponse) Reset()         { *m = MsgRedeemBasketTokenResponse{} }
func (m *MsgRedeemBasketTokenResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRedeemBasketTokenResponse) ProtoMessage()    {}
func (*MsgRedeemBasketTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{5}
}
func (m *MsgRedeemBasketTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRedeemBasketTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRedeemBasketTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRedeemBasketTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRedeemBasketTokenResponse.Merge(m, src)
}
func (m *MsgRedeemBasketTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRedeemBasketTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRedeemBasketTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRedeemBasketTokenResponse proto.InternalMessageInfo

func (m *MsgRedeemBasketTokenResponse) GetPendingRedemptionId() uint64 {
	if m != nil {
		return m.PendingRedemptionId
	}
	return 0
}

func (m *MsgRedeemBasketTokenResponse) GetCompletionTime() string {
	if m != nil {
		return m.CompletionTime
	}
	return ""
}

// MsgConvertDelegation defines a message to convert an existing delegation to basket tokens
type MsgConvertDelegation struct {
	// delegator is the address of the delegator
	Delegator string `protobuf:"bytes,1,opt,name=delegator,proto3" json:"delegator,omitempty"`
	// validator_address is the address of the validator to convert from
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	// amount is the amount of delegation to convert
	Amount types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	// basket_id is the ID of the basket to convert to
	BasketId string `protobuf:"bytes,4,opt,name=basket_id,json=basketId,proto3" json:"basket_id,omitempty"`
}

func (m *MsgConvertDelegation) Reset()         { *m = MsgConvertDelegation{} }
func (m *MsgConvertDelegation) String() string { return proto.CompactTextString(m) }
func (*MsgConvertDelegation) ProtoMessage()    {}
func (*MsgConvertDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{6}
}
func (m *MsgConvertDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConvertDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConvertDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConvertDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConvertDelegation.Merge(m, src)
}
func (m *MsgConvertDelegation) XXX_Size() int {
	return m.Size()
}
func (m *MsgConvertDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConvertDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConvertDelegation proto.InternalMessageInfo

func (m *MsgConvertDelegation) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *MsgConvertDelegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgConvertDelegation) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *MsgConvertDelegation) GetBasketId() string {
	if m != nil {
		return m.BasketId
	}
	return ""
}

// MsgConvertDelegationResponse is the response for MsgConvertDelegation
type MsgConvertDelegationResponse struct {
	// shares_minted is the amount of basket tokens minted
	SharesMinted cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=shares_minted,json=sharesMinted,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"shares_minted"`
}

func (m *MsgConvertDelegationResponse) Reset()         { *m = MsgConvertDelegationResponse{} }
func (m *MsgConvertDelegationResponse) String() string { return proto.CompactTextString(m) }
func (*MsgConvertDelegationResponse) ProtoMessage()    {}
func (*MsgConvertDelegationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{7}
}
func (m *MsgConvertDelegationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConvertDelegationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConvertDelegationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConvertDelegationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConvertDelegationResponse.Merge(m, src)
}
func (m *MsgConvertDelegationResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgConvertDelegationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConvertDelegationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConvertDelegationResponse proto.InternalMessageInfo

// MsgConvertBasket defines a message to convert basket tokens from one basket to another
type MsgConvertBasket struct {
	// converter is the address converting the basket tokens
	Converter string `protobuf:"bytes,1,opt,name=converter,proto3" json:"converter,omitempty"`
	// from_basket_id is the ID of the source basket
	FromBasketId string `protobuf:"bytes,2,opt,name=from_basket_id,json=fromBasketId,proto3" json:"from_basket_id,omitempty"`
	// to_basket_id is the ID of the destination basket
	ToBasketId string `protobuf:"bytes,3,opt,name=to_basket_id,json=toBasketId,proto3" json:"to_basket_id,omitempty"`
	// amount is the amount of source basket tokens to convert
	Amount types.Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgConvertBasket) Reset()         { *m = MsgConvertBasket{} }
func (m *MsgConvertBasket) String() string { return proto.CompactTextString(m) }
func (*MsgConvertBasket) ProtoMessage()    {}
func (*MsgConvertBasket) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{8}
}
func (m *MsgConvertBasket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConvertBasket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConvertBasket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConvertBasket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConvertBasket.Merge(m, src)
}
func (m *MsgConvertBasket) XXX_Size() int {
	return m.Size()
}
func (m *MsgConvertBasket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConvertBasket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConvertBasket proto.InternalMessageInfo

func (m *MsgConvertBasket) GetConverter() string {
	if m != nil {
		return m.Converter
	}
	return ""
}

func (m *MsgConvertBasket) GetFromBasketId() string {
	if m != nil {
		return m.FromBasketId
	}
	return ""
}

func (m *MsgConvertBasket) GetToBasketId() string {
	if m != nil {
		return m.ToBasketId
	}
	return ""
}

func (m *MsgConvertBasket) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgConvertBasketResponse is the response for MsgConvertBasket
type MsgConvertBasketResponse struct {
	// shares_minted is the amount of destination basket tokens minted
	SharesMinted cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=shares_minted,json=sharesMinted,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"shares_minted"`
}

func (m *MsgConvertBasketResponse) Reset()         { *m = MsgConvertBasketResponse{} }
func (m *MsgConvertBasketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgConvertBasketResponse) ProtoMessage()    {}
func (*MsgConvertBasketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa903f4423a27b03, []int{9}
}
func (m *MsgConvertBasketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgConvertBasketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgConvertBasketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgConvertBasketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgConvertBasketResponse.Merge(m, src)
}
func (m *MsgConvertBasketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgConvertBasketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgConvertBasketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgConvertBasketResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreateBasket)(nil), "celestia.lst.v1.MsgCreateBasket")
	proto.RegisterType((*MsgCreateBasketResponse)(nil), "celestia.lst.v1.MsgCreateBasketResponse")
	proto.RegisterType((*MsgMintBasketToken)(nil), "celestia.lst.v1.MsgMintBasketToken")
	proto.RegisterType((*MsgMintBasketTokenResponse)(nil), "celestia.lst.v1.MsgMintBasketTokenResponse")
	proto.RegisterType((*MsgRedeemBasketToken)(nil), "celestia.lst.v1.MsgRedeemBasketToken")
	proto.RegisterType((*MsgRedeemBasketTokenResponse)(nil), "celestia.lst.v1.MsgRedeemBasketTokenResponse")
	proto.RegisterType((*MsgConvertDelegation)(nil), "celestia.lst.v1.MsgConvertDelegation")
	proto.RegisterType((*MsgConvertDelegationResponse)(nil), "celestia.lst.v1.MsgConvertDelegationResponse")
	proto.RegisterType((*MsgConvertBasket)(nil), "celestia.lst.v1.MsgConvertBasket")
	proto.RegisterType((*MsgConvertBasketResponse)(nil), "celestia.lst.v1.MsgConvertBasketResponse")
}

func init() { proto.RegisterFile("celestia/lst/v1/tx.proto", fileDescriptor_aa903f4423a27b03) }

var fileDescriptor_aa903f4423a27b03 = []byte{
	// 988 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0x7f, 0x48, 0xa6, 0x69, 0xd3, 0x2c, 0x29, 0x75, 0xd6, 0xa9, 0xe3, 0x2c, 0x2d,
	0xa4, 0x29, 0xde, 0xad, 0x0d, 0x2a, 0x52, 0x38, 0xe1, 0x44, 0x48, 0x91, 0x6a, 0x0e, 0x4b, 0x55,
	0x24, 0x2e, 0xd6, 0x78, 0x77, 0x98, 0x8c, 0xe2, 0xdd, 0x59, 0xed, 0x4c, 0xad, 0x56, 0x70, 0xa8,
	0x7a, 0x83, 0x53, 0x11, 0xdf, 0x81, 0x73, 0x0e, 0xf9, 0x00, 0x1c, 0xcb, 0xad, 0x4a, 0x2f, 0x88,
	0x43, 0x84, 0x12, 0xa4, 0x7c, 0x02, 0x0e, 0xdc, 0xd0, 0xfc, 0xd9, 0xb5, 0xbd, 0x6b, 0x88, 0x41,
	0xca, 0xc5, 0x9a, 0x79, 0xef, 0x37, 0xef, 0xfd, 0xfc, 0x7b, 0xf3, 0xde, 0x2c, 0x28, 0xfb, 0xa8,
	0x87, 0x18, 0x27, 0xd0, 0xed, 0x31, 0xee, 0xf6, 0x1b, 0x2e, 0x7f, 0xea, 0xc4, 0x09, 0xe5, 0xd4,
	0x5c, 0x4a, 0x3d, 0x4e, 0x8f, 0x71, 0xa7, 0xdf, 0xb0, 0xd6, 0xf2, 0xd0, 0x2e, 0x64, 0x07, 0x88,
	0x2b, 0xb8, 0xb5, 0x82, 0x29, 0xa6, 0x72, 0xe9, 0x8a, 0x95, 0xb6, 0xae, 0x61, 0x4a, 0x71, 0x0f,
	0xb9, 0x30, 0x26, 0x2e, 0x8c, 0x22, 0xca, 0x21, 0x27, 0x34, 0x62, 0xda, 0x7b, 0xd3, 0xa7, 0x2c,
	0xa4, 0xcc, 0x0d, 0x19, 0x16, 0xf1, 0x42, 0x86, 0xb5, 0x63, 0x55, 0x39, 0x3a, 0x2a, 0x9e, 0xda,
	0x68, 0x57, 0x55, 0x9f, 0xe9, 0x42, 0x86, 0xdc, 0x7e, 0xa3, 0x8b, 0x38, 0x6c, 0xb8, 0x3e, 0x25,
	0x91, 0xf6, 0x2f, 0xc3, 0x90, 0x44, 0xd4, 0x95, 0xbf, 0xca, 0x64, 0xff, 0x69, 0x80, 0xa5, 0x36,
	0xc3, 0x3b, 0x09, 0x82, 0x1c, 0xb5, 0x24, 0x69, 0xb3, 0x09, 0xde, 0xf2, 0xc5, 0x9e, 0x26, 0x65,
	0xa3, 0x66, 0x6c, 0x2e, 0xb4, 0xca, 0xc7, 0x47, 0xf5, 0x15, 0x9d, 0xe9, 0xd3, 0x20, 0x48, 0x10,
	0x63, 0x5f, 0xf0, 0x84, 0x44, 0xd8, 0x4b, 0x81, 0xe6, 0x67, 0x00, 0xf4, 0x61, 0x8f, 0x04, 0x62,
	0xc3, 0xca, 0xa5, 0xda, 0xf4, 0xe6, 0x95, 0x66, 0xcd, 0xc9, 0xc9, 0xe4, 0x3c, 0x4e, 0x21, 0x5f,
	0x22, 0x82, 0xf7, 0x79, 0x6b, 0xe6, 0xd5, 0xc9, 0xfa, 0x94, 0x37, 0x74, 0xd2, 0xfc, 0x04, 0xcc,
	0x87, 0x88, 0xc3, 0x00, 0x72, 0x58, 0x9e, 0xae, 0x19, 0x9b, 0x57, 0x9a, 0xeb, 0x85, 0x28, 0x8a,
	0x66, 0x5b, 0xc3, 0xbc, 0xec, 0xc0, 0xf6, 0xdd, 0x17, 0xe7, 0x87, 0x5b, 0x29, 0xa5, 0xef, 0xcf,
	0x0f, 0xb7, 0x06, 0x15, 0xcc, 0xfd, 0x47, 0xfb, 0x21, 0xb8, 0x99, 0x33, 0x79, 0x88, 0xc5, 0x34,
	0x62, 0xc8, 0xac, 0x80, 0x05, 0x55, 0xbd, 0x0e, 0x09, 0x94, 0x00, 0xde, 0xbc, 0x32, 0xec, 0x05,
	0xe6, 0x0a, 0x98, 0x0d, 0x50, 0x44, 0xc3, 0x72, 0x49, 0x3a, 0xd4, 0xc6, 0xfe, 0xc5, 0x00, 0x66,
	0x9b, 0xe1, 0x36, 0x89, 0xb8, 0x0a, 0xf6, 0x88, 0x1e, 0xa0, 0xc8, 0xbc, 0x0f, 0xe6, 0x42, 0x12,
	0x71, 0x74, 0xb1, 0x8e, 0x1a, 0x37, 0x9a, 0xbb, 0x94, 0xcb, 0xfd, 0x31, 0x98, 0x83, 0x21, 0x7d,
	0x12, 0x71, 0xad, 0xcc, 0xaa, 0xa3, 0x63, 0x89, 0x7a, 0x3b, 0xba, 0xde, 0xce, 0x0e, 0x25, 0x91,
	0x16, 0x56, 0xc3, 0xb7, 0xef, 0x09, 0x5d, 0x74, 0x0a, 0x21, 0x4b, 0x65, 0x58, 0x96, 0x1c, 0x69,
	0x9b, 0x03, 0xab, 0x68, 0xcd, 0xc4, 0x79, 0x0c, 0xae, 0xb2, 0x7d, 0x98, 0x20, 0xd6, 0x91, 0xe1,
	0xb4, 0x40, 0xad, 0x86, 0xc8, 0xf7, 0xdb, 0xc9, 0x7a, 0x45, 0x31, 0x62, 0xc1, 0x81, 0x43, 0xa8,
	0x1b, 0x42, 0xbe, 0xef, 0x3c, 0x44, 0x18, 0xfa, 0xcf, 0x76, 0x91, 0x7f, 0x7c, 0x54, 0x07, 0x9a,
	0xf0, 0x2e, 0xf2, 0xbd, 0x45, 0x15, 0xa7, 0x2d, 0xc3, 0xd8, 0x6f, 0x0c, 0xb0, 0xd2, 0x66, 0xd8,
	0x43, 0x01, 0x42, 0xe1, 0xb0, 0x86, 0x1f, 0x81, 0xf9, 0x44, 0x1a, 0x27, 0x50, 0x31, 0x43, 0x5e,
	0x92, 0x8e, 0xae, 0xd0, 0x31, 0x4b, 0x22, 0x94, 0xbc, 0x35, 0xac, 0x64, 0x81, 0xbc, 0xfd, 0x0d,
	0x58, 0x1b, 0x67, 0xcf, 0xd4, 0x6c, 0x82, 0x1b, 0x31, 0x8a, 0x02, 0x12, 0xe1, 0x8e, 0x88, 0x1a,
	0xc6, 0x62, 0x02, 0xa4, 0xd7, 0x6e, 0xc6, 0x7b, 0x5b, 0x3b, 0xbd, 0xcc, 0xb7, 0x17, 0x98, 0xef,
	0x83, 0x25, 0x9f, 0x86, 0x71, 0x0f, 0x49, 0x2c, 0x27, 0x21, 0xd2, 0x7f, 0xf0, 0xda, 0xc0, 0xfc,
	0x88, 0x84, 0xc8, 0xfe, 0xa9, 0x24, 0x25, 0xdd, 0xa1, 0x51, 0x1f, 0x25, 0x7c, 0x17, 0xf5, 0x10,
	0x96, 0x13, 0xc6, 0x7c, 0x00, 0x16, 0x02, 0xb5, 0x9b, 0xa0, 0xc3, 0x07, 0x50, 0xf3, 0x73, 0xb0,
	0x9c, 0x75, 0x6a, 0x07, 0x2a, 0x94, 0xca, 0xdd, 0xda, 0x38, 0x3e, 0xaa, 0xdf, 0xd2, 0xe7, 0xb3,
	0x26, 0x1f, 0x0d, 0x74, 0xbd, 0x9f, 0xb3, 0xff, 0xef, 0x3a, 0x8c, 0x56, 0x77, 0x66, 0xb4, 0xba,
	0xdb, 0xf7, 0x45, 0x91, 0x06, 0xac, 0x0b, 0x55, 0x2a, 0xe8, 0x61, 0xf7, 0x65, 0x95, 0x0a, 0xf6,
	0x4b, 0xbf, 0xf3, 0x7f, 0x19, 0xe0, 0xfa, 0x20, 0xb1, 0x1e, 0xbe, 0x0f, 0xc0, 0x82, 0xaf, 0x0c,
	0x13, 0x5c, 0xf8, 0x01, 0xd4, 0xbc, 0x0d, 0xae, 0x7d, 0x9d, 0xd0, 0xb0, 0x93, 0xbf, 0xf6, 0x8b,
	0xc2, 0xda, 0x4a, 0xaf, 0x7e, 0x0d, 0x2c, 0x72, 0x3a, 0x84, 0x99, 0x96, 0x18, 0xc0, 0x69, 0xab,
	0xd8, 0x1c, 0x33, 0xff, 0xad, 0x39, 0x3e, 0x90, 0xba, 0x67, 0x84, 0x84, 0xee, 0xab, 0x63, 0x74,
	0xd7, 0xf3, 0x37, 0x01, 0xe5, 0xbc, 0xed, 0xb2, 0xf5, 0x6e, 0xfe, 0x3c, 0x0b, 0xa6, 0xdb, 0x0c,
	0x9b, 0xdf, 0x82, 0xc5, 0x91, 0xf7, 0xae, 0xf8, 0x4e, 0xe5, 0x9e, 0x06, 0x6b, 0xf3, 0x22, 0x44,
	0xca, 0xdd, 0xae, 0xbd, 0x78, 0xf3, 0xc7, 0x8f, 0x25, 0x6b, 0xdb, 0xd8, 0xb2, 0x6f, 0xa4, 0xdf,
	0x02, 0xf2, 0x41, 0x42, 0x5a, 0x75, 0xf3, 0x3b, 0xf1, 0xe2, 0xe6, 0x1e, 0x8a, 0x77, 0xc7, 0xc5,
	0xcf, 0x81, 0xac, 0x7b, 0x13, 0x80, 0x32, 0x1e, 0xb7, 0x25, 0x8f, 0xaa, 0xe0, 0xb1, 0x9a, 0xf2,
	0x10, 0x6a, 0xa6, 0xb5, 0xe7, 0x32, 0xef, 0x0f, 0x06, 0x58, 0x2e, 0x8e, 0xdc, 0x3b, 0xe3, 0x12,
	0x15, 0x60, 0x56, 0x7d, 0x22, 0x58, 0xc6, 0xe8, 0x3d, 0xc9, 0xa8, 0x26, 0x18, 0x55, 0x52, 0x46,
	0x6a, 0x94, 0x8e, 0x72, 0x7a, 0x69, 0x80, 0xe5, 0xe2, 0xcc, 0x1a, 0xcb, 0xa9, 0x00, 0x1b, 0xcf,
	0xe9, 0x1f, 0x3b, 0xdb, 0xbe, 0x23, 0x39, 0xad, 0x0b, 0x4e, 0x56, 0x56, 0x2d, 0x85, 0xee, 0x04,
	0x83, 0xe4, 0xcf, 0x0d, 0x70, 0x75, 0xb4, 0x4b, 0x37, 0xfe, 0x25, 0x8f, 0xbe, 0x33, 0x77, 0x2f,
	0x84, 0x64, 0x34, 0x36, 0x24, 0x8d, 0x8a, 0xa0, 0xf1, 0x4e, 0x9e, 0x86, 0xd2, 0xc6, 0x9a, 0x7d,
	0x7e, 0x7e, 0xb8, 0x65, 0xb4, 0xf6, 0x5e, 0x9d, 0x56, 0x8d, 0xd7, 0xa7, 0x55, 0xe3, 0xf7, 0xd3,
	0xaa, 0xf1, 0xf2, 0xac, 0x3a, 0xf5, 0xfa, 0xac, 0x3a, 0xf5, 0xeb, 0x59, 0x75, 0xea, 0x2b, 0x17,
	0x13, 0xbe, 0xff, 0xa4, 0xeb, 0xf8, 0x34, 0x74, 0xd3, 0xc4, 0x34, 0xc1, 0xd9, 0xba, 0x0e, 0xe3,
	0xd8, 0x7d, 0x2a, 0xa3, 0xf3, 0x67, 0x31, 0x62, 0xdd, 0x39, 0xf9, 0x01, 0xf8, 0xe1, 0xdf, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x2a, 0x60, 0xb1, 0xee, 0xe6, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateBasket creates a new basket of validators
	CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error)
	// MintBasketToken mints basket tokens by staking TIA
	MintBasketToken(ctx context.Context, in *MsgMintBasketToken, opts ...grpc.CallOption) (*MsgMintBasketTokenResponse, error)
	// RedeemBasketToken redeems basket tokens for TIA (with unbonding period)
	RedeemBasketToken(ctx context.Context, in *MsgRedeemBasketToken, opts ...grpc.CallOption) (*MsgRedeemBasketTokenResponse, error)
	// ConvertDelegation converts an existing delegation to basket tokens
	ConvertDelegation(ctx context.Context, in *MsgConvertDelegation, opts ...grpc.CallOption) (*MsgConvertDelegationResponse, error)
	// ConvertBasket converts basket tokens from one basket to another
	ConvertBasket(ctx context.Context, in *MsgConvertBasket, opts ...grpc.CallOption) (*MsgConvertBasketResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateBasket(ctx context.Context, in *MsgCreateBasket, opts ...grpc.CallOption) (*MsgCreateBasketResponse, error) {
	out := new(MsgCreateBasketResponse)
	err := c.cc.Invoke(ctx, "/celestia.lst.v1.Msg/CreateBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintBasketToken(ctx context.Context, in *MsgMintBasketToken, opts ...grpc.CallOption) (*MsgMintBasketTokenResponse, error) {
	out := new(MsgMintBasketTokenResponse)
	err := c.cc.Invoke(ctx, "/celestia.lst.v1.Msg/MintBasketToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RedeemBasketToken(ctx context.Context, in *MsgRedeemBasketToken, opts ...grpc.CallOption) (*MsgRedeemBasketTokenResponse, error) {
	out := new(MsgRedeemBasketTokenResponse)
	err := c.cc.Invoke(ctx, "/celestia.lst.v1.Msg/RedeemBasketToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ConvertDelegation(ctx context.Context, in *MsgConvertDelegation, opts ...grpc.CallOption) (*MsgConvertDelegationResponse, error) {
	out := new(MsgConvertDelegationResponse)
	err := c.cc.Invoke(ctx, "/celestia.lst.v1.Msg/ConvertDelegation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ConvertBasket(ctx context.Context, in *MsgConvertBasket, opts ...grpc.CallOption) (*MsgConvertBasketResponse, error) {
	out := new(MsgConvertBasketResponse)
	err := c.cc.Invoke(ctx, "/celestia.lst.v1.Msg/ConvertBasket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateBasket creates a new basket of validators
	CreateBasket(context.Context, *MsgCreateBasket) (*MsgCreateBasketResponse, error)
	// MintBasketToken mints basket tokens by staking TIA
	MintBasketToken(context.Context, *MsgMintBasketToken) (*MsgMintBasketTokenResponse, error)
	// RedeemBasketToken redeems basket tokens for TIA (with unbonding period)
	RedeemBasketToken(context.Context, *MsgRedeemBasketToken) (*MsgRedeemBasketTokenResponse, error)
	// ConvertDelegation converts an existing delegation to basket tokens
	ConvertDelegation(context.Context, *MsgConvertDelegation) (*MsgConvertDelegationResponse, error)
	// ConvertBasket converts basket tokens from one basket to another
	ConvertBasket(context.Context, *MsgConvertBasket) (*MsgConvertBasketResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateBasket(ctx context.Context, req *MsgCreateBasket) (*MsgCreateBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBasket not implemented")
}
func (*UnimplementedMsgServer) MintBasketToken(ctx context.Context, req *MsgMintBasketToken) (*MsgMintBasketTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintBasketToken not implemented")
}
func (*UnimplementedMsgServer) RedeemBasketToken(ctx context.Context, req *MsgRedeemBasketToken) (*MsgRedeemBasketTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemBasketToken not implemented")
}
func (*UnimplementedMsgServer) ConvertDelegation(ctx context.Context, req *MsgConvertDelegation) (*MsgConvertDelegationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertDelegation not implemented")
}
func (*UnimplementedMsgServer) ConvertBasket(ctx context.Context, req *MsgConvertBasket) (*MsgConvertBasketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertBasket not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/celestia.lst.v1.Msg/CreateBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBasket(ctx, req.(*MsgCreateBasket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintBasketToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintBasketToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintBasketToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/celestia.lst.v1.Msg/MintBasketToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintBasketToken(ctx, req.(*MsgMintBasketToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RedeemBasketToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRedeemBasketToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RedeemBasketToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/celestia.lst.v1.Msg/RedeemBasketToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RedeemBasketToken(ctx, req.(*MsgRedeemBasketToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ConvertDelegation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgConvertDelegation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ConvertDelegation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/celestia.lst.v1.Msg/ConvertDelegation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ConvertDelegation(ctx, req.(*MsgConvertDelegation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ConvertBasket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgConvertBasket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ConvertBasket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/celestia.lst.v1.Msg/ConvertBasket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ConvertBasket(ctx, req.(*MsgConvertBasket))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "celestia.lst.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBasket",
			Handler:    _Msg_CreateBasket_Handler,
		},
		{
			MethodName: "MintBasketToken",
			Handler:    _Msg_MintBasketToken_Handler,
		},
		{
			MethodName: "RedeemBasketToken",
			Handler:    _Msg_RedeemBasketToken_Handler,
		},
		{
			MethodName: "ConvertDelegation",
			Handler:    _Msg_ConvertDelegation_Handler,
		},
		{
			MethodName: "ConvertBasket",
			Handler:    _Msg_ConvertBasket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "celestia/lst/v1/tx.proto",
}

func (m *MsgCreateBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BasketId) > 0 {
		i -= len(m.BasketId)
		copy(dAtA[i:], m.BasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBasketToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBasketToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBasketToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BasketId) > 0 {
		i -= len(m.BasketId)
		copy(dAtA[i:], m.BasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Minter) > 0 {
		i -= len(m.Minter)
		copy(dAtA[i:], m.Minter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Minter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintBasketTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintBasketTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintBasketTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharesMinted.Size()
		i -= size
		if _, err := m.SharesMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgRedeemBasketToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemBasketToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemBasketToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BasketId) > 0 {
		i -= len(m.BasketId)
		copy(dAtA[i:], m.BasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Redeemer) > 0 {
		i -= len(m.Redeemer)
		copy(dAtA[i:], m.Redeemer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Redeemer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRedeemBasketTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRedeemBasketTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRedeemBasketTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompletionTime) > 0 {
		i -= len(m.CompletionTime)
		copy(dAtA[i:], m.CompletionTime)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CompletionTime)))
		i--
		dAtA[i] = 0x12
	}
	if m.PendingRedemptionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PendingRedemptionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgConvertDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConvertDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConvertDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketId) > 0 {
		i -= len(m.BasketId)
		copy(dAtA[i:], m.BasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketId)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgConvertDelegationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConvertDelegationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConvertDelegationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharesMinted.Size()
		i -= size
		if _, err := m.SharesMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgConvertBasket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConvertBasket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConvertBasket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ToBasketId) > 0 {
		i -= len(m.ToBasketId)
		copy(dAtA[i:], m.ToBasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ToBasketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FromBasketId) > 0 {
		i -= len(m.FromBasketId)
		copy(dAtA[i:], m.FromBasketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromBasketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Converter) > 0 {
		i -= len(m.Converter)
		copy(dAtA[i:], m.Converter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Converter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgConvertBasketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgConvertBasketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgConvertBasketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharesMinted.Size()
		i -= size
		if _, err := m.SharesMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintBasketToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Minter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgMintBasketTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesMinted.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRedeemBasketToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Redeemer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRedeemBasketTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PendingRedemptionId != 0 {
		n += 1 + sovTx(uint64(m.PendingRedemptionId))
	}
	l = len(m.CompletionTime)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgConvertDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.BasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgConvertDelegationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesMinted.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgConvertBasket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Converter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.FromBasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ToBasketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgConvertBasketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SharesMinted.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, ValidatorWeight{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &BasketMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBasketToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBasketToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBasketToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Minter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintBasketTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintBasketTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintBasketTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemBasketToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemBasketToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemBasketToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redeemer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redeemer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRedeemBasketTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRedeemBasketTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRedeemBasketTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingRedemptionId", wireType)
			}
			m.PendingRedemptionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingRedemptionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConvertDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConvertDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConvertDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConvertDelegationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConvertDelegationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConvertDelegationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConvertBasket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConvertBasket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConvertBasket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Converter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Converter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromBasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromBasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToBasketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToBasketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgConvertBasketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgConvertBasketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgConvertBasketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
